<!DOCTYPE html><html><head><meta charset="utf-8" /><script type="text/javascript" src="./system/hpmd.js"></script></head><body data-format="swipe" data-lang="ru" data-sys-format="teaser" data-sys-subformat="swipe">

<!-- == HTML =========================================================================================== -->
<section>
				<!-- «Растяжка» снизу. Этот элемент подкладывается в конец
				     тела страницы и делается равным тизеру по высоте,
				     чтобы тизер не перекрывал подвал страницы -->
				<div id="hpmd-stretch"></div>
				<!-- «Обертка». Сам элемент находится за пределами viewport,
				     но нужен, чтобы передать дочерним элементам размеры
				     «окна» браузера. -->
				<div id="hpmd-wrapper">
					<!-- Расхлоп -->
					<div id="hpmd-popup">
						<!-- Заглушка.
								Этот элемент «выдвигается» из-под тизера при свайпе
								вверх; остальные элементы появляются после полного
								раскрытия баннера. -->
						<div id="hpmd-splash">
							<!-- Кнопка закрытия -->
							<div id="hpmd-popup-close"></div>
		
						</div>
						<!-- Расхлоп -->
						<div id="hpmd-popup-contents">
		
		
							<div class="hpmd-game-visual">
								<div class="hpmd-header-arrow"></div>
								<div class="hpmd-header-text"></div>
								<div class="hpmd-footer-arrow"></div>
								<div class="hpmd-footer-text"></div>
							</div>
		
							<iframe id="hpmd-frame" src="./banner/res/game.html" frameborder="0"></iframe>
		
							<div class="hpmd-logo"></div>
		
							<div class="hpmd-final-screen hpmd-hidden">
								<div class="hpmd-try-now"></div>
								<div class="hpmd-list"></div>
								<div class="hpmd-medal"></div>
								<div class="hpmd-pack"></div>
								<div class="hpmd-button"></div>
								<div class="hpmd-ligal"></div>
							</div>
		
						</div>
					</div>
					
					<!-- Тизер -->
					<div id="hpmd-teaser" class="hpmd-teaser">
						<!-- «Ярлычок» -->
						<div id="hpmd-handle">
							<!-- Вы можете использовать макет http://misc.hpmdnetwork.ru/template/swipe/handle.psd,
									чтобы кастомизировать ярлычок -->
							<div class="hpmd-handler-text"></div>
							<div class="hpmd-arrow"></div>
							<div class="hpmd-arrow"></div>
						</div>
						<div class="hpmd-teaser-logo"></div>
						<div class="hpmd-teaser-shirt">
							<div class="hpmd-spots-box">
								<div class="hpmd-spot-1"></div>
								<div class="hpmd-spot-2"></div>
								<div class="hpmd-spot-3"></div>
								<div class="hpmd-spot-4"></div>
								<div class="hpmd-spot-5"></div>
							</div>
						</div>
						<div class="hpmd-teaser-text"></div>
					</div>
					
				</div>
</section>
<!-- /HTML -->

<!-- == CSS ============================================================================================ -->
<style>
				#hpmd-frame {
					width: 100%;
					height: 100%;
					position: absolute;
					top: 0%;
					left: 0%;
				}
				/* «Обертка» */
				.hpmd-landscape {
					display: none!important;
				}
		
				#hpmd-wrapper {
					/* Прибита к низу экрана */
					position: fixed;
					
					/* Сохраняем ширину и высоту для дочерних элементов */
					width: 100%;
					height: 100%;
					
					/* «Прибиваем» к нижней части экрана */
					bottom: 0;
					
					/* Сдвигаем за пределы viewport, чтобы элемент-обертка не перекрывал
					 * основной контент страницы */
					left: -100%;
					
					/* Размещаем поверх всех элементов площадки */
					z-index: 2147483647;
					
					/* Отключаем «проглатывание» pointer-событий в Windows Phone
					 * для всех элементов баннера */
					-ms-touch-action: none;
					touch-action: none;
				}
				
				/* Тизер */
				#hpmd-teaser {
					position: absolute;
					
					/* Сдвигаем в видимую область экрана */
					left: 100%;
					
					/* Прибиваем к нижней границе экрана */
					bottom: 0;
					
					/* Растягиваем на всю ширину экрана */
					width: 100%;
					
					/* Размещаем выше расхлопа */
					z-index: 10000;
					
					/* Анимации появления и исчезновения */
					transition: bottom .3s, opacity .3s, -webkit-transform .3s;
					-moz-transition: bottom .3s, opacity .3s, transform .3s, -moz-transform .3s;
					transition: bottom .3s, opacity .3s, transform .3s;
					transition: bottom .3s, opacity .3s, transform .3s, -webkit-transform .3s, -moz-transform .3s, -o-transform .3s;
					-webkit-transition: bottom .3s, opacity .3s, -webkit-transform .3s;
					-moz-transition: bottom .3s, opacity .3s, -moz-transform .3s;
					-ms-transition: bottom .3s, opacity .3s, -ms-transform .3s;
					-o-transition: bottom .3s, opacity .3s, -o-transform .3s;
				}
				
				/* Анимация сворачивания тизера */
				#hpmd-teaser.hpmd-close {
					/* При сворачивании тизер уходит в прозрачность и исчезает
					 * за нижней границей экрана: */
					opacity: 0.0;
					transform: translate(0, 100%);
					-webkit-transform: translate(0, 100%);
					-moz-transform: translate(0, 100%);
					-ms-transform: translate(0, 100%);
					-o-transform: translate(0, 100%);
				}
				
				/* Расхлоп */
				#hpmd-popup {
					position: absolute;
					
					/* Сдвигаем в видимую область экрана */
					left: 100%;
					
					/* Прибиваем к нижней границе экрана */
					bottom: 0;
					
					/* Растягиваем на всю ширину экрана */
					width: 100%;
					
					/* Изначальное состояние расхлопа: */
					height: 0;
					
					/* Фоновая заливка на случай, если расхлоп был вытянут
					 * более чем на высоту экрана: */
					background: #000;
				}
				
				/* Заглушка */
				#hpmd-splash {
					/* Растягиваем на весь размер родительского элемента */
					position: absolute;
					left: 0;
					top: 0;
					width: 100%;
					height: 100%;
					
					/* Скрываем лишнее.
					 * 
					 * Если какой-то из элементов будет выступать вправо или вниз,
					 * это может разрушить верстку площадки из-за неверного вычисления
					 * браузером ширины контента.
					 * 
					 * Чтобы избежать проблем, ограничиваем баннер областью попапа:
					 */
					overflow: hidden;
				}
				
				/* Кнопка закрытия */
				#hpmd-popup-close {
					/* Анимация и начальное состояние кнопки: */
					opacity: 0.0;
					transition: opacity .6s;
					-webkit-transition: opacity .6s;
					-moz-transition: opacity .6s;
					-ms-transition: opacity .6s;
					-o-transition: opacity .6s;
					
					/* Прибиваем кнопку к правому верхнему углу: */
					position: absolute;
					right: 0;
					top: 0;
					
					/* Располагаем кнопку над прочими элементами баннера: */
					z-index: 1000;
					
					/* Картинка кнопки закрытия, по центру: */
					background: url(./banner/img/close.png) 50% 50% no-repeat;
					/* Делаем размер иконки половиной от всего размера кнопки, так,
					 * чтобы область для клика была достаточно большой, чтобы в нее
					 * можно было уверенно попасть пальцем, но иконка не казалась
					 * громадной:
					 */
					background-size: 50% auto;
				}
				#hpmd-popup-close.hpmd-show {
					/* Анимация появления кнопки при раскрытии расхлопа */
					opacity: 1.0;
				}
				
				/* Основное содержимое расхлопа */
				#hpmd-popup-contents {
					/* Растягиваем на весь размер родительского элемента: */
					position: absolute;
					left: 0;
					top: 0;
					width: 100%;
					height: 100%;
					
					/* Запрещаем выход элементов за пределы расхлопа: */
					overflow: hidden;
				}
		
				.hpmd-game-visual {
					width: 100%;
					height: 100%;
					position: absolute;
					left: 0;
					right: 0;
				}
				.hpmd-logo {
					background: url(./banner/img/logo.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					left: 13%;
					top: 0;
					width: 30%;
					height: 11%;
				}
				.hpmd-header-arrow {
					background: url(./banner/img/arrow.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					width: 20%;
					height: 12%;
					left: 13%;
					top: 56%;
				}
		
				.hpmd-header-text {
					background: url(./banner/img/crash.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					width: 31%;
					height: 10%;
					left: 6%;
					top: 66%;
				}
		
				.hpmd-footer-arrow {
					background: url(./banner/img/arrow.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					width: 17%;
					height: 12%;
					left: 64%;
					top: 69%;
					transform: rotate(180deg);
				}
				.hpmd-footer-text {
					background: url("./banner/img/move.png") 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					width: 24%;
					height: 20%;
					left: 70%;
					top: 55%;
				}
		
		
				.hpmd-footer-text {
					-webkit-animation: blink1 2s linear infinite;
					animation: blink1 2s linear infinite;
				}
				@-webkit-keyframes blink1 {
					0% { transform: scale(1) }
					50% { transform: scale(1.1) }
					100% { transform: scale(1) }
				}
				@keyframes blink1 {
					0% { transform: scale(1) }
					50% { transform: scale(1.1) }
					100% { transform: scale(1) }
				}
		
				.hpmd-header-text {
					-webkit-animation: blink2 2s linear infinite;
					animation: blink2 2s linear infinite;
				}
				@-webkit-keyframes blink2 {
					0% { transform: scale(1.1) }
					50% { transform: scale(1) }
					100% { transform: scale(1.1) }
				}
				@keyframes blink2 {
					0% { transform: scale(1.1) }
					50% { transform: scale(1) }
					100% { transform: scale(1.1) }
				}
				.hpmd-final-screen {
					background: #ffffff url("./banner/img/bg.jpg") 0% 50% no-repeat;
					background-size: cover;
					width: 100%;
					height: 100%;
					position: absolute;
					top: 0;
					left: 0;
					opacity: 0;
					transition: opacity .5s linear;
				}
		
				.hpmd-hidden {
					display: none!important;
				}
		
				.hpmd-try-now {
					background: url(./banner/img/try_now.png) 00% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 3%;
					left: 0%;
					width: 70%;
					height: 10%;
				}
				.hpmd-list {
					background: url(./banner/img/list.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 17%;
					left: 4%;
					width: 54%;
					height: 28%;
				}
				.hpmd-medal {
					background: url(./banner/img/medal.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 18%;
					left: 59%;
					width: 35%;
					height: 25%;
				}
				.hpmd-pack {
					background: url(./banner/img/platform.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 49%;
					left: 24%;
					width: 74%;
					height: 31%;
				}
				.hpmd-ligal {
					background: url(./banner/img/ligal.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					bottom: 1%;
					left: 5%;
					width: 64%;
					height: 5%;
				}
				.hpmd-button {
					position: absolute;
					left: 35%;
					top: 84%;
					background: url(./banner/img/button.png) 50% 50% no-repeat;
					background-size: contain;
					width: 60%;
					height: 10%;
				}
				
				/* Анимация и начальное состояние расхлопа */
				#hpmd-popup {
					opacity: 0.0;
					-o-transition: bottom .3s, height .6s ease, opacity .6s ease-in;
					-moz-transition: bottom .3s, height .6s ease, opacity .6s ease-in;
					transition: bottom .3s, height .6s ease, opacity .6s ease-in;
					-webkit-transition: bottom .3s, height .6s ease, opacity .6s ease-in;
					-moz-transition: height .6s ease, opacity .6s ease-in;
					-ms-transition: height .6s ease, opacity .6s ease-in;
					-o-transition: height .6s ease, opacity .6s ease-in;
				}
				/* Отключение анимации, когда пользователь взаимодействует с тизером */
				#hpmd-popup.hpmd-no-transition {
					transition: none;
					-webkit-transition: none;
					-moz-transition: none;
					-ms-transition: none;
					-o-transition: none;
					opacity: 1.0;
				}
				/* Полностью раскрытое состояние расхлопа */
				#hpmd-popup.hpmd-open {
					opacity: 1.0;
					height: 100%;
				}
				
				/* Скрытое состояние тизера */
				#hpmd-teaser.hpmd-hide {
					opacity: 0.0;
				}
				
				/* Скрываем основное содержимое расхлопа, чтобы избежать
				 * загрузки всей графики расхлопа, когда на экране
				 * только тизер: */
				#hpmd-popup-contents {
					display: none;
				}
				
				/* «Ярлычок» тизера */
				#hpmd-handle {
					/* Растягиваем на всю ширину тизера */
					position: absolute;
					left: 0;
					right: 0;
					
					/* Сдвигаем элемент снизу на высоту тизера:
					 * делаем так, чтобы элемент начинался там,
					 * где кончается тизер */
					bottom: 100%;
					
					/* Делаем так, чтобы элемент кончался на 24% выше
					 * верхней границы тизера. В сочетании с предыдущим
					 * правилом это определяет высоту ярлычка ― 24%
					 * высоты тизера */
					top: -30%;
					
					/* Задаем фоновую картинку и центрируем ее */
					background: url(./banner/img/handle.png) 50% 50% no-repeat;
					/* Растягиваем фоновую картинку на всю высоту элемента */
					-o-background-size: auto 100%;
					   background-size: auto 100%;
				}
				
				/* Анимация стрелочек в ярлычке */
				@-moz-keyframes hpmd-arrowkf {
					from {
						-moz-transform: translateY(0);
						     transform: translateY(0);
					}
					50% {
						-moz-transform: translateY(30%);
						     transform: translateY(30%);
					}
					to {
						-moz-transform: translateY(0);
						     transform: translateY(0);
					}
				}
				@keyframes hpmd-arrowkf {
					from {
						-webkit-transform: translateY(0);
						   -moz-transform: translateY(0);
						     -o-transform: translateY(0);
						        transform: translateY(0);
					}
					50% {
						-webkit-transform: translateY(30%);
						   -moz-transform: translateY(30%);
						     -o-transform: translateY(30%);
						        transform: translateY(30%);
					}
					to {
						-webkit-transform: translateY(0);
						   -moz-transform: translateY(0);
						     -o-transform: translateY(0);
						        transform: translateY(0);
					}
				}
				@-webkit-keyframes hpmd-arrowkf {
					from {
						-webkit-transform: translateY(0);
					}
					50% {
						-webkit-transform: translateY(30%);
					}
					to {
						-webkit-transform: translateY(0);
					}
				}
				@-o-keyframes hpmd-arrowkf {
					from {
						-o-transform: translateY(0);
					}
					50% {
						-o-transform: translateY(30%);
					}
					to {
						-o-transform: translateY(0);
					}
				}
				/* Стрелочки в ярлычке */
				#hpmd-handle .hpmd-arrow {
					position: absolute;
					width: 70%;
					height: 40%;
					top: 23%;
					left: 15%;
					background: url(./banner/img/handle-arrow.png) 35.4% 50% no-repeat;
					-o-background-size: contain;
					   background-size: contain;
					-moz-transform-origin: 50% 50%;
					     transform-origin: 50% 50%;
					-webkit-transform-origin: 50% 50%;
					-ms-transform-origin: 50% 50%;
					-o-transform-origin: 50% 50%;
					-moz-animation: hpmd-arrowkf 1s ease-in-out infinite;
					     animation: hpmd-arrowkf 1s ease-in-out infinite;
					-webkit-animation: hpmd-arrowkf 1s ease-in-out infinite;
					-ms-animation: hpmd-arrowkf 1s ease-in-out infinite;
					-o-animation: hpmd-arrowkf 1s ease-in-out infinite;
				}
				#hpmd-handle .hpmd-arrow+.hpmd-arrow {
					background-position: 64.8% 50%;
				}
		
				.hpmd-handler-text {
					background: url("./banner/img/start_teaser.png") 50% 50% no-repeat;
					background-size: contain;
					height: 55%;
					position: absolute;
					top: 20%;
					width: 50%;
					left: 25%;
				}
				.hpmd-teaser-logo {
					background: url(./banner/img/teaser_logo.png) 50% 50% no-repeat;
					background-size: contain;
					width: 32%;
					height: 55%;
					position: absolute;
					top: 24%;
					left: 0%;
				}
				.hpmd-teaser-shirt {
					background: url(./banner/img/shirt.png) 50% 50% no-repeat;
					background-size: contain;
					width: 40%;
					height: 200%;
					position: absolute;
					top: -6%;
					left: 30%;
				}
				.hpmd-teaser-text {
					background: url("./banner/img/play_teaser.png") 50% 50% no-repeat;
					background-size: contain;
					width: 30%;
					height: 42%;
					position: absolute;
					top: 28%;
					right: 2%;
				}
				.hpmd-spots-box {
					width: 100%;
					height: 100%;
					position: absolute;
					left: 0;
					top: 0;
				}
				.hpmd-spots-box {
					-webkit-animation: spotsBlink 1.5s linear infinite;
					animation: spotsBlink 1.5s linear infinite;
				}
				@-webkit-keyframes spotsBlink {
					0% { opacity: 1 }
					50% { opacity: 0 }
					100% { opacity: 1 }
				}
				@keyframes spotsBlink {
					0% { opacity: 1 }
					50% { opacity: 0 }
					100% { opacity: 1 }
				}
				.hpmd-teaser-shirt .hpmd-spot-1 {
					background: url(./banner/img/red_spot.png) 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 16%;
					left: 21%;
					width: 24%;
					height: 16%;
				}
				.hpmd-teaser-shirt .hpmd-spot-2 {
					background: url("./banner/img/grey_spot.png") 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 22%;
					left: 35%;
					width: 24%;
					height: 16%;
				}
				.hpmd-teaser-shirt .hpmd-spot-3 {
					background: url("./banner/img/black_spot.png") 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 12%;
					left: 54%;
					width: 24%;
					height: 16%;
				}
				.hpmd-teaser-shirt .hpmd-spot-4 {
					background: url("./banner/img/black_spot.png") 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 34%;
					left: 21%;
					width: 24%;
					height: 16%;
				}
				.hpmd-teaser-shirt .hpmd-spot-5 {
					background: url("./banner/img/red_spot.png") 50% 50% no-repeat;
					background-size: contain;
					position: absolute;
					top: 35%;
					left: 47%;
					width: 24%;
					height: 16%;
				}
				/* Стрелочки в ярлычке в ландшафтной ориентации */
				.hpmd-landscape #hpmd-handle .hpmd-arrow {
					background-position: 44% 50%;
				}
				.hpmd-landscape #hpmd-handle .hpmd-arrow+.hpmd-arrow {
					background-position: 56.1% 50%;
				}
				
				/* Высота тизера и изображение в нем в портретной ориентации */
				.hpmd-portrait #hpmd-teaser {
					/* Высота = 22.2% ширины экрана */
					padding-top: 22.2%;
					
					/* Задаем фоновую картинку, центрируем ее по горизонтали и растягиваем
					 * на все доступное место. */
					background: url(./banner/img/teaser-portrait.png) 50% 50% no-repeat;
					/* заставляем фоновую картинку «застелить» весь элемент.
					 * Если картинка не соответствует пропорциям, она будет обрезана
					 * либо снизу, либо слева и справа. */
					background-size: cover;
				}
				/* Размер и изображение тизера в ландшафтной ориентации */
				.hpmd-landscape #hpmd-teaser {
					/* Высота = 8.85% ширины экрана */
					padding-top: 8.85%;
					
					/* Задаем фоновую картинку, центрируем ее по горизонтали и растягиваем
					 * на все доступное место. */
					background: url(./banner/img/teaser-landscape.png) 50% 50% no-repeat;
					/* заставляем фоновую картинку «застелить» весь элемент.
					 * Если картинка не соответствует пропорциям, она будет обрезана
					 * либо снизу, либо слева и справа. */
					background-size: cover;
				}
				
				
				/* Фоновая картинка заглушки в портретной ориентации */
				.hpmd-portrait #hpmd-splash {
					background: #fff;
				}
				/* Фоновая картинка заглушки в ландшафтной ориентации */
				.hpmd-landscape  {
					display: none!important;
				}
				
				/* Размеры кнопки закрытия в портретной ориентации: */
				.hpmd-portrait #hpmd-popup-close {
					/* Ширина = 20% ширины экрана */
					width: 20%;
					/* Высота = 20% ширины экрана */
					padding-top: 20%;
				}
</style>
<!-- /CSS -->

<!-- == JS ============================================================================================= -->
<script>_hpmd.testBanner(function () {
		try {
				/**
				 * Используем пространство имен hpmd.data для организации баннера.
				 * Переменная hpmd гарантированно объявлена к моменту запуска баннера.
				 */
				hpmd.data = {
		
					/**
					 * ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
					 */
		
					/**
					 * Определяет, находится ли устройство в портретной ориентации
					 *
					 * В качестве аргумента dimensions можно передать объект с ключами
					 * width и height, описывающих ширину и высоту viewport.
					 *
					 * @return bool
					 */
					isPortrait: function (dimensions) {
						if (!dimensions) {
							// если измерения не переданы,
							// используем текущие размеры окна
							dimensions = {
								width: window.innerWidth,
								height: window.innerHeight,
							};
						}
		
						// проверяем ориентацию
						return dimensions.width < dimensions.height;
					},
		
					/**
					 * Управляется ли устройство iOS
					 *
					 * @return bool
					 */
					isIOs: function () {
						return hpmd.getSegment("os") == "iOS";
					},
		
					/**
					 * Управляется ли устройство Android
					 *
					 * @return bool
					 */
					isAndroid: function () {
						return hpmd.getSegment("os") == "Android";
					},
		
					/**
					 * Управляется ли устройство Windows Phone
					 *
					 * @return bool
					 */
					isWP: function () {
						return hpmd.getSegment("os") == "Windows";
					},
		
					/**
					 * Загружает список изображений в кэш браузера
					 * и вызывает callback, когда загрузка завершена
					 *
					 * @param string[] images Список URL загружаемых картинок
					 * @param Function callback Функция обратного вызова по завершении загрузки
					 */
					preloadImages: function (images, callback) {
						var loaded = 0, imageObjects = [];
						var handler = function () {
							loaded++;
							if (loaded == images.length && !!callback) {
								callback();
							}
						};
						for (var i = 0; i < images.length; i++) {
							imageObjects[i] = new Image();
							imageObjects[i].onload = handler;
							imageObjects[i].onerror = handler;
							imageObjects[i].src = images[i];
						}
					},
		
					/**
					 * Регистрирует обработчик события
					 *
					 * @param DOMElement element DOM-элемент
					 * @param string event Название события (напр., "touchstart"))
					 * @param Function handler Обработчик события
					 */
					attachHandler: function (element, event, handler) {
						if (hpmd.data.isWP()) {
							switch (event) {
								case "touchstart":
									hpmd.data.attachHandler(element, 'MSPointerDown', handler);
									hpmd.data.attachHandler(element, 'pointerdown', handler);
									break;
								case "touchmove":
									hpmd.data.attachHandler(element, 'MSPointerMove', handler);
									hpmd.data.attachHandler(element, 'pointermove', handler);
									break;
								case "touchend":
									hpmd.data.attachHandler(element, 'MSPointerUp', handler);
									hpmd.data.attachHandler(element, 'pointerup', handler);
									break;
								case "touchcancel":
									hpmd.data.attachHandler(element, 'MSPointerCancel', handler);
									hpmd.data.attachHandler(element, 'pointercancel', handler);
									break;
							}
						}
		
						element.addEventListener(event, handler, false);
					},
		
					/**
					 * Удаляет обработчик события
					 *
					 * @param DOMElement element DOM-элемент
					 * @param string event Название события (напр., "touchstart"))
					 * @param Function handler Обработчик события
					 */
					detachHandler: function (element, event, handler) {
						if (hpmd.data.isWP()) {
							switch (event) {
								case "touchstart":
									hpmd.data.detachHandler(element, 'MSPointerDown', handler);
									hpmd.data.detachHandler(element, 'pointerdown', handler);
									break;
								case "touchmove":
									hpmd.data.detachHandler(element, 'MSPointerMove', handler);
									hpmd.data.detachHandler(element, 'pointermove', handler);
									break;
								case "touchend":
									hpmd.data.detachHandler(element, 'MSPointerUp', handler);
									hpmd.data.detachHandler(element, 'pointerup', handler);
									break;
								case "touchcancel":
									hpmd.data.detachHandler(element, 'MSPointerCancel', handler);
									hpmd.data.detachHandler(element, 'pointercancel', handler);
									break;
							}
						}
		
						element.removeEventListener(event, handler, false);
					},
		
					/**
					 * Обрабатывает жесты пользователя
					 *
					 * Эта функция служит для обработки свайпов в четырех направлениях
					 * (влево, вправо, вверх, вниз) и «тапа» по любому элементу.
					 *
					 * В качестве первого аргумента передается DOM-элемент;
					 * в качестве второго аргумента передается объект, содержащий
					 * некоторые (или все) из следующих ключей:
					 * - left
					 * - right
					 * - down
					 * - up
					 * - tap
					 *
					 * Значения ключей должны быть функциями.
					 *
					 * При обнаружении свайпа в определенном направлении вызывается
					 * соответствующая функция; в качестве аргументов ей передается
					 * экземпляр события touchend и ссылка на исходный DOM-элемент.
					 *
					 * Например:
					 * hpmd.data.handleSwipe(document.getElementById('hpmd-my-node'), {
					 *    up: function () {
					 *       alert("Swipe up!");
					 *    },
					 *    down: function () {
					 *       alert("Swipe down!");
					 *    },
					 *    tap: function (event, element) {
					 *       alert("Tapped on " + element + "!");
					 *    },
					 * });
					 *
					 * @param DOMElement element
					 * @param object handlers
					 */
					handleSwipe: function (element, handlers) {
						var x, y;
		
						hpmd.data.attachHandler(element, 'touchstart', function (event) {
							var touch = !!event.changedTouches ? event.changedTouches[0] : event;
		
							x = touch.pageX;
							y = touch.pageY;
							event.preventDefault();
		
							if (!!event.stopPropagation) {
								event.stopPropagation();
								event.cancelBubble = true;
							}
						});
						hpmd.data.attachHandler(element, 'touchend', function (event) {
							var touch = !!event.changedTouches ? event.changedTouches[0] : event;
							var direction = hpmd.data.calcSwipeDirection(touch.pageX - x, touch.pageY - y);
							if (!!handlers[direction]) {
								handlers[direction](event, element);
							}
		
							if (!!event.stopPropagation) {
								event.stopPropagation();
								event.cancelBubble = true;
							}
						});
					},
		
					/**
					 * Отключает скролл на странице.
					 */
					disableScroll: function () {
						// Чтобы отключить скролл, «давим» все события touchmove и touchend.
						hpmd.data.attachHandler(document, 'touchmove', hpmd.data.cancelEvent);
						hpmd.data.attachHandler(document, 'touchend', hpmd.data.cancelEvent);
					},
		
					/**
					 * Восстанавливает скролл на странице.
					 */
					enableScroll: function () {
						// Удаляем обработчик событий touchmove и touchend, подавляющий их.
						hpmd.data.detachHandler(document, 'touchmove', hpmd.data.cancelEvent);
						hpmd.data.detachHandler(document, 'touchend', hpmd.data.cancelEvent);
					},
		
					/**
					 * «Отменяет» событие.
					 *
					 * Используется в качестве обработчика события,
					 * обработки которого нужно избежать (например,
					 * запрет скролла)..)
					 */
					cancelEvent: function (event) {
						event.preventDefault();
					},
		
		
					// ///////////////////////////////////////////////
		
					/**
					 * СОСТОЯНИЕ ИНТЕРФЕЙСА БАННЕРА
					 */
		
					/**
					 * Выполняется ли закрытие баннера
					 * (флаг установлен, если происходит анимация закрытия)
					 *
					 * @var bool
					 */
					bannerClosing: false,
					/**
					 * Раскрыт ли фуллскрин
					 *
					 * @var bool
					 */
					bannerOpened: false,
					/**
					 * Свернут ли тизер
					 *
					 * @var bool
					 */
					bannerMinimized: false,
		
		
					// ///////////////////////////////////////////////
		
					/**
					 * ВНУТРЕННИЕ ФУНКЦИИ
					 */
		
					/**
					 * Список DOM-элементов, принадлежащих баннеру
					 *
					 * @var object of DOMElement
					 */
					nodes: {},
		
					/**
					 * Возвращает расстояние от верха страницы до верхней
					 * границы тизера в пикселях (для использования вместе
					 * с pageY, полученным от touch-события)
					 *
					 * @return int
					 */
					getTeaserOffset: function () {
						var offset = 0, node = hpmd.data.nodes.teaser;
						while (node) {
							offset += node.offsetTop;
							node = node.offsetParent;
						}
						return offset;
					},
		
					/**
					 * Определяет направление свайпа по смещению
					 * точки прикосновения
					 *
					 * Смещение вправо и вниз ― положительное,
					 * влево и вверх ― отрицательное.
					 *
					 * @param number deltax Смещение в пикселях по горизонтали вправо
					 * @param number deltay Смещение в пикселях по вертикали вниз
					 *
					 * @return string "tap", "left", "right", "up", "down"
					 */
					calcSwipeDirection: function (deltax, deltay) {
						if (deltax == 0) {
							if (deltay == 0) {
								// смещения нет, произошел тап
								return "tap";
							} else {
								// смещение есть, зададим deltay равным единице,
								// чтобы избежать деления на ноль
								deltay = 1;
							}
						}
						if (Math.abs(deltax) < 10 && Math.abs(deltay) < 10) {
							// смещение меньше 10 пикселей, произошел тап
							return "tap";
						}
						if (Math.abs(deltay / deltax) > .5) {
							// наклон кривой к горизонтали больше 45°,
							// это вертикальный свайп,
							if (deltay < 0) {
								// смещение вверх
								return "up";
							} else {
								// смещение вниз
								return "down";
							}
						} else {
							// наклон кривой к горизонтали меньше 45°,
							// это горизонтальный свайп,
							if (deltax < 0) {
								// смещение влево
								return "left";
							} else {
								// смещение вправо
								return "right";
							}
						}
					},
		
					/**
					 * Обрабатывает DOM-элемент тизера
					 *
					 * Устанавливает все необходимые обработчики событий
					 * для обработки взаимодействия пользователя с тизером.
					 *
					 * @param DOMElement node
					 */
					processTeaserNode: function (node) {
						var offsetY, deltaY, startX, startY, progress;
		
						/**
						 * Обработчик события touchstart / pointerdown
						 */
						var handlerStart = function (event) {
							if (hpmd.data.bannerOpened || hpmd.data.nodes.teaser.getBoundingClientRect().bottom < window.innerHeight * 0.9) {
								// Залетело «шальное» событие при открытом баннере,
								// игнорируем его
								return;
							}
							if (hpmd.data.isWP()) {
								// Включаем pointer capture на Windows Phone.
								// Без этого событие pointerup не генерируется,
								// если пользователь «отпустил» прикосновение
								// за пределами исходного элемента.
								node.setPointerCapture(event.pointerId);
							}
		
							// event.changedTouches для события touchstart,
							// event для события pointerdown
							var touch = !!event.changedTouches ? event.changedTouches[0] : event;
		
							// Вычисляем, в какой точке относительно тизера
							// начался жест.
							startX = touch.pageX;
							startY = touch.pageY;
							offsetY = hpmd.data.getTeaserOffset();
							if (startY < offsetY) {
								deltaY = offsetY - startY;
							} else {
								deltaY = 0;
							}
		
							// Отключаем CSS3-анимации фуллскрина, чтобы его движение
							// вслед за «пальцем» не тормозило.
							hpmd.data.nodes.popup.className = 'hpmd-no-transition';
		
							// Отключем обработку события остальными элементами и браузером.
							event.preventDefault();
							event.stopPropagation();
						};
		
						/**
						 * Обработчик события touchmove / pointermove
						 */
						var handlerMove = function (event) {
							if (hpmd.data.bannerOpened) {
								// Залетело «шальное» событие при открытом баннере,
								// игнорируем его
								return;
							}
		
							// event.changedTouches для события touchstart,
							// event для события pointerdown
							var touch = !!event.changedTouches ? event.changedTouches[0] : event;
		
							// Смотрим, на какую долю высоты окна сместилось прикосновение
							progress = (startY - touch.pageY) / window.innerHeight;
		
							if (progress < 0) {
								// Указатель сместился вниз.
								// Чтобы не задавать отрицательную высоту и не ловить баги в iOS,
								// возвращаем все в исходное состояние.
								hpmd.data.rollbackPopup();
							} else if (progress < 1.0) {
								// «Открываем» фуллскрин на то же самое расстояние, на которое
								// был смещен палец.
								hpmd.data.nodes.popup.style.height = (startY - touch.pageY + hpmd.data.nodes.teaser.offsetHeight) + 'px';
							}
		
							// Отключем обработку события остальными элементами и браузером.
							event.preventDefault();
							event.stopPropagation();
						};
		
						var handlerCancel = function (event) {
							if (hpmd.data.bannerOpened) {
								// Залетело «шальное» событие при открытом баннере,
								// игнорируем его
								return;
							}
		
							// Слишком много пальцев, палец за пределами экрана,
							// либо аппаратный сбой. Возвращаем все на место.
							hpmd.data.rollbackPopup();
		
							// Отключем обработку события остальными элементами и браузером.
							event.preventDefault();
							event.stopPropagation();
						};
		
						var handlerEnd = function (event) {
							if (hpmd.data.bannerOpened) {
								// Залетело «шальное» событие при открытом баннере,
								// игнорируем его
								return;
							}
		
							// event.changedTouches для события touchend,
							// event для события pointerup
							var touch = !!event.changedTouches ? event.changedTouches[0] : event;
		
							// Определяем, в каком направлении в итоге сместился палец
							var direction = hpmd.data.calcSwipeDirection(touch.pageX - startX, touch.pageY - startY);
		
							if (direction == "down") {
								// Вниз? Возвращаем все назад...
								hpmd.data.rollbackPopup();
								// ...и сворачиваем тизер.
								hpmd.data.collapseTeaser(true);
							} else if (progress > .4 || direction == "tap") {
								if (direction == "tap") {
									hpmd.trackEvent('tap-on-teaser');
								} else if (progress > .4) {
									hpmd.trackEvent('swipe-on-teaser');
								}
								// Тап, либо палец продвинулся больше чем на 40% экрана.
								// Разворачиваем фуллскрин.
								hpmd.data.openBanner();
								hpmd.data.timeoutId = setTimeout(function(){
									hpmd.data.hiddenStartScreen();
									hpmd.data.sendMessage({
										name: 'hpmd',
										action: 'start'
									})
								}, 5000)
							} else {
								// Произошло что-то другое (например, свайп вбок),
								// возвращаем все на место.
								hpmd.data.rollbackPopup();
							}
		
							// Отключем обработку события остальными элементами и браузером.
							event.preventDefault();
							event.stopPropagation();
						};
		
						// Регистрируем обработчики.
						hpmd.data.attachHandler(node, 'touchstart', handlerStart);
						hpmd.data.attachHandler(node, 'touchmove', handlerMove);
						hpmd.data.attachHandler(node, 'touchcancel', handlerCancel);
						hpmd.data.attachHandler(node, 'touchend', handlerEnd);
					},
		
					timeoutId: 0,
		
					/**
					 * Обрабатывает DOM-элемент, принадлежащий баннеру.
					 *
					 * Если ID имеет префикс "hpmd-", сохраняет ссылку на элемент в объекте
					 * hpmd.data.nodes для быстрого доступа; ключом является ID элемента без префикса.
					 *
					 * Элементы с классом "hpmd-teaser" считаются тизерами; им присваиваются
					 * необходимые обработчики ошибок.
					 *
					 * После завершения функция рекурсивно обрабатывает все дочерние элементы.
					 *
					 * @param DOMElement node
					 */
					processNode: function (node) {
						// Проверяем ID.
						var attribute;
						if (!!node.getAttribute && !!(attribute = node.getAttribute('id')) && attribute.indexOf('hpmd-') === 0) {
							// Нашли префикс "hpmd-", сохраняем на будущее.
							hpmd.data.nodes[attribute.substring(5, 1000)] = node;
						}
		
						// Проверяем тизерные элементы.
						if (/(^|\s)hpmd-teaser($|\s)/.exec(node.className)) {
							// Нашли класс "hpmd-teaser", регистрируем нужные обработчики.
							hpmd.data.processTeaserNode(node);
						}
		
						// Обрабатываем дочерние элементы.
						for (var i = 0; i < node.children.length; i++) {
							hpmd.data.processNode(node.children[i]);
						}
					},
		
					/**
					 * Возвращает фуллскрин в исходное, свернутое состояние.
					 */
					rollbackPopup: function () {
						hpmd.data.nodes.popup.style.height = '';
						hpmd.data.nodes.popup.className = '';
					},
		
					/**
					 * Раскрывает расхлоп
					 */
					openBanner: function () {
						if (hpmd.data.bannerOpened || hpmd.data.bannerClosing) {
							// Баннер уже раскрыт или закрывается. Скорее всего,
							// этот вызов ― ошибочный. Игнорируем.
							return;
						}
		
						// Скролл на ноль пикселей скрывает смарт-баннер на iOS.
						window.scrollBy(0, 0);
		
						// Помечаем баннер как открытый.
						hpmd.data.bannerOpened = true;
		
						// Сообщаем системе о раскрытии...
						hpmd.events.fire("expand");
						// ...и регистрируем соответствующее событие.
						hpmd.trackEvent("hpmd.expand");
		
						// Сохраняем время раскрытия (для дальнейшего вызова hpmd.time-expanded).
						hpmd.data.openedAt = new Date();
		
						// На случай, если попап оставлен в полуоткрытом состоянии, возвращаем его в состояние.
						hpmd.data.rollbackPopup();
						// Скрываем тизер
						hpmd.data.collapseTeaser();
		
						/* TODO: добавьте сюда все, что должно быть сделано
						 * при выводе фуллскрина и может быть сделано, пока он
						 * все еще находится в display: none.
						 * 
						 * Если HTML-код фуллскрина создается динамически, это
						 * следует делать здесь.
						 * 
						 * Исполнение этого кода гарантированно происходит в контексте события
						 * пользовательского ввода (click, touch- и pointer-события).
						 * 
						 * Действия, которые требуют такого контекста (например,
						 * инициализация и автозапуск <video>-элемента) следует
						 * выполнить здесь.
						 */
		
						// Теперь, когда подготовительая работа проведена, нужно
						// дать возможность браузеру отреагировать на window.scrollBy().
						// Для этого устанавливаем нулевой таумаут и выходим из функции.
						setTimeout(function () {
							/* TODO: добавьте сюда все, что должно быть выполнено
							 * перед началом анимации раскрытия расхлопа (например, preload
							 * материалов, динамическое создание кода фуллскрина,
							 * добавление обработчиков событий и т.п).
							 */
							hpmd.data.nodes['popup-contents'].style.display = 'block';
		
							// Открываем фуллскрин (добавление этого класса запускает CSS3-анимацию).
							hpmd.data.nodes.popup.className = 'hpmd-open';
		
							// Ждем завершения анимации.
							// В строгом соответствии нет необходимости, поэтому
							// проще воспользоваться таймаутом в 600 мс, чем обрабатывать
							// события transitionEnd со всеми vendor-префиксами, vendor-фичами и 
							// vendor-багами.
							setTimeout(function () {
								// Показываем кнопку закрытия (добавление этого класса запускает CSS3-анимацию).
								hpmd.data.nodes['popup-close'].className = 'hpmd-show';
		
								/**
								 * TODO: добавьте сюда все, что должно быть выполнено после завершения
								 * анимации (например, загрузка требовательных к ресурсам материалов,
								 * таких, как сторонние видеоплейеры, мини-сайты в IFRAME и т.п.).
								 *
								 * Если вам нужно поработать со скроллом или глобальными событиями,
								 * это также делается здесь.
								 */
		
		
								// Отключаем скролл на странице.
								hpmd.data.disableScroll();
							}, 600);
						}, 0);
					},
		
					/**
					 * Закрывает баннер
					 */
					minimizeBanner: function () {
						if (!hpmd.data.bannerOpened || hpmd.data.bannerClosing) {
							// Баннер уже раскрыт или закрывается. Скорее всего,
							// этот вызов ― ошибочный. Игнорируем.
							return;
						}
		
						// Сообщаем системе о закрытии...
						hpmd.events.fire("collapse");
						// ...и регистрируем соответствующие события.
						if (!!hpmd.data.openedAt) {
							hpmd.trackEvent("hpmd.close");
							// Время с момента раскрытия баннера в секундах, округленное
							// по математическим правилам.
							hpmd.trackEvent("hpmd.time-expanded", {weight: Math.round(((new Date()) - hpmd.data.openedAt) / 1000)});
						}
		
						// Помечаем баннер как закрытый...
						hpmd.data.bannerOpened = false;
						// ...и тизер как свернутый.
						hpmd.data.bannerMinimized = true;
		
						/**
						 * TODO: здесь можно отменить действия, которые были выполнены
						 * при раскрытии баннера (освободить память, удалить лишние
						 * обработчики событий).
						 */
		
						// Включаем скролл на странице.
						hpmd.data.enableScroll();
		
						// Скрываем кнопку закрытия (удаление класса запускает CSS3-анимацию).
						hpmd.data.nodes['popup-close'].className = '';
						// Сворачиваем фуллскрин (удаление класса запускает CSS3-анимацию).
						hpmd.data.nodes.popup.className = hpmd.data.nodes.popup.className.replace(/(^|\s+)hpmd-open(\s+|$)/, '');
		
						// Помечаем старт анимации...
						hpmd.data.bannerClosing = true;
						setTimeout(function () {
							// ...и ее завершение через 600 мс.
							hpmd.data.bannerClosing = false;
		
							// Полностью убираем баннер со страницы, чтобы скрытые
							// элементы в дальнейшем не конфликтовали с прочими
							// элементами страницами и интерфейсом браузера.
							hpmd.data.destroy();
						}, 600);
					},
		
					/**
					 * Сворачивает тизер
					 */
					collapseTeaser: function (standalone) {
						if (!!standalone) {
							// Событие hpmd.collapse регистрируется только в том случае,
							// если сворачивание тизера не следует за раскрытием баннера.
							hpmd.trackEvent("hpmd.collapse");
						}
		
						/**
						 * TODO: если при сворачивании тизера требуются какие-либо изменения
						 * (например, скрытие выступающих элементов), добавьте сюда инструкции,
						 * которые будут выполнять эти изменения.
						 */
		
						// Скрываем сам тизер.
						hpmd.data.nodes.teaser.className = 'hpmd-close';
						if (!!standalone) {
							// Убираем баннер со страницы после завершения анимации.
							// При сворачивании тизера ждем 300 мс ― длительность анимации тизера.
							setTimeout(hpmd.data.destroy, 300);
						}
		
						// Помечаем тизер как свернутый.
						hpmd.data.bannerMinimized = true;
						// Пересчитываем верстку, чтобы обнулить высоту элемента-растяжки.
						hpmd.data.onViewportUpdate();
					},
					sendMessage: function(data) {
						document.getElementById('hpmd-frame').contentWindow.postMessage(JSON.stringify(data), '*');
					},
					/**
					 * Полностью убирает все элементы баннера со страницы.
					 */
					destroy: function () {
						/* Отключите здесь любые обработчики событий,
						 * которые были включены при запуске или в процессе
						 * работы баннера.
						 */
		
						// На случай, если скролл в данный момент отключен,
						// пробуем включить его.
						hpmd.data.enableScroll();
		
						// Отключаем слежение за размерами экрана и ориентацией
						if (!!hpmd.data.watchLayoutInterval) {
							clearInterval(hpmd.data.watchLayoutInterval);
						}
		
						// Удаляем все HTML-элементы баннера.
						for (var k in hpmd.data.nodes) {
							if (hpmd.data.nodes.hasOwnProperty(k)) {
								try {
									hpmd.data.nodes[k].parentNode.removeChild(hpmd.data.nodes[k]);
								} catch (e) {
								}
							}
						}
					},
		
					watchLayoutInterval: null,
		
					/**
					 * Запускает слежение за размерами «окна» браузера
					 *
					 * Результатом выполнения этой функции будет отслеживание
					 * изменений в размерах окна браузера и вызов hpmd.data.onViewportUpdate
					 * при обнаружении изменений.
					 */
					watchLayout: function () {
						// Проверяем размер окна по событию scroll (при скролле может быть показана
						// или скрыта панель навигации браузера).
						hpmd.data.attachHandler(window, 'scroll', hpmd.data.checkLayout);
						// Проверяем размер окна, если браузер был так добр, что сообщил нам об изменениях.
						hpmd.data.attachHandler(window, 'resize', hpmd.data.checkLayout);
						// Проверяем размер окна при смене ориентации.
						hpmd.data.attachHandler(window, 'orientationchange', function () {
							// iOS сначала меняет ориентацию, а затем обновляет размеры 
							// панели навигации, поэтому первое вычисление даст неверные
							// результаты. Проверяем еще раз через 150 мс, когда все    
							// утрясется.
							var updated = false;
							if (!hpmd.data.checkOrientation()) {
								updated = hpmd.data.checkLayout();
							} else {
								updated = true;
							}
							if (updated && hpmd.data.isIOs() && !hpmd.data.bannerOpened) {
								hpmd.data.nodes.wrapper.style.visibility = 'hidden';
								setTimeout(function () {
									hpmd.data.nodes.wrapper.style.visibility = '';
		
									// window.innerWidth и window.innerHeight остаются старыми в iOS,    
									// даже если фактически размеры изменились; обновляются они только   
									// после скролла. Для получения актуальных значений имитируем скролл.
									// (Это действие сгенерирует событие scroll, в котором пойдет
									// дальнейшая обработка ситуации.)
									window.scrollBy(0, 0);
								}, 150);
							}
						});
						// Проверяем размер окна при завершении прикосновения. Жест зума может
						// изменять размер окна, не генерируя событий resize и scroll.        
						hpmd.data.attachHandler(document, 'touchend', hpmd.data.checkLayoutEnd);
						hpmd.data.attachHandler(document, 'touchcancel', hpmd.data.checkLayoutEnd);
						// Перепроверяем размер окна по факту загрузки страницы.
						hpmd.data.attachHandler(window, 'load', hpmd.data.checkLayout);
						// Перепроверяем размер окна по факту загрузки DOM; в этот момент браузер
						// уже должен определиться с текущим масштабом страницы.
						hpmd.data.attachHandler(document, 'DOMContentLoaded', hpmd.data.checkLayout);
		
						// В некоторых случаях - например, при «тапе» на панели навигации браузера -   
						// нам не везет, и никаких событий не вызывается. Проверяем три раза в секунду,
						// не изменился ли размер окна.                                                .)
						hpmd.data.watchLayoutInterval = setInterval(hpmd.data.checkLayout, 330);
		
						// 500 мс, как правило, достаточно для обработки таблицы стилей площадки
						// и определения масштаба страницы, так что по истечении этого времени  
						// попробуем еще раз проверить размер окна.                             
						setTimeout(hpmd.data.forceCheckLayout, 500);
					},
		
					/**
					 * Проверяет размеры окна браузера при завершении или отмене касания
					 */
					checkLayoutEnd: function (event) {
						// Делаем проверку, только если все касания завершены;    
						// в противном случае жест еще не закончен.               
						// Проверка `!event.touches` для событий на Windows Phone.
						if (!event.touches || event.touches.length <= 0) {
							setTimeout(function () {
								hpmd.data.forceCheckLayout();
							}, 0);
						}
					},
		
					/**
					 * Последние зарегистрированные параметры окна браузера
					 */
					lastLayout: {
						width: null,
						height: null,
						orientation: null,
					},
		
					/**
					 * Проверяет, не изменилась ли ориентация; если изменилась,
					 * обновляет верстку в соответствии с новыми размерами.
					 *
					 * @return bool True в случае наличия изменений.
					 */
					checkOrientation: function () {
						if (hpmd.data.lastLayout.orientation != window.orientation) {
							hpmd.data.forceCheckLayout();
							return true;
						}
						return false;
					},
		
					/**
					 * Проверяет, не изменились ли размеры окна браузера.
					 * Если изменились, обновляет верстку в соответствии
					 * с новыми размерами.
					 *
					 * @return bool True в случае наличия изменений.
					 */
					checkLayout: function () {
						if (hpmd.data.lastLayout.width != window.innerWidth || hpmd.data.lastLayout.height != window.innerHeight) {
							hpmd.data.forceCheckLayout();
							return true;
						}
						return false;
					},
		
					/**
					 * Сохраняет новые размеры окна браузера и запускает
					 * процедуру обновления верстки.
					 */
					forceCheckLayout: function () {
		
						if (hpmd.data.isLoaded) {
							hpmd.data.nodes.wrapper.className = hpmd.data.isPortrait() ? 'hpmd-portrait' : 'hpmd-landscape';
						}
						hpmd.data.lastLayout = {
							width: window.innerWidth,
							height: window.innerHeight,
							orientation: window.orientation,
						};
						hpmd.data.updateLayout();
					},
		
					/**
					 * Флаг повторного обновления, workaround для бага в iOS 7.
					 * @var bool
					 */
					secondLayoutUpdate: false,
					/**
					 * Запускает процедуру обновления верстки.
					 */
					updateLayout: function () {
						// Workaround для бага в iOS 7, см. выше.
						if (hpmd.data.secondLayoutUpdate || !hpmd.data.isIOs()) {
							hpmd.data.nodes.wrapper.style.visibility = 'visible';
						}
						hpmd.data.secondLayoutUpdate = true;
		
						// Запускаем пользовательскую функцию пересчета верстки.
						hpmd.data.onViewportUpdate();
		
						if (hpmd.data.bannerOpened) {
							// Заставляем браузер перерисовать верстку фуллскрина
							// и внешний вид панели навигации с изменениями.
							window.scrollBy(0, 0);
						}
					},
					/**
					 * Инициализирует баннер
					 */
					init: function () {
						// Обрабатываем все HTML-элементы баннера, начиная с корневых.
						// Таких в баннере два: #hpmd-wrapper и #hpmd-stretch.
						hpmd.data.processNode(document.getElementById('hpmd-wrapper'));
						hpmd.data.processNode(document.getElementById('hpmd-stretch'));
		
						// Кнопка закрытия обязательно должна находиться в исходном коде,
						// т.к. в противном случае что-то может не загрузиться и баннер
						// будет невозможно закрыть.
						if (!hpmd.data.nodes['popup-close']) {
							window.console && console.log("[HPMD Framework] There's a problem with your ad layout; it should include #hpmd-popup-close element.");
						} else {
							// Обрабатываем закрытие баннера при нажатии на кнопку.
							hpmd.data.handleSwipe(hpmd.data.nodes['popup-close'], {
								tap: hpmd.data.minimizeBanner
							});
						}
		
						// Не позволяем событию touchstart выйти за пределы баннера.
						hpmd.data.attachHandler(hpmd.data.nodes.wrapper, 'touchstart', function (event) {
							event.stopPropagation();
						});
		
						// Начинаем наблюдение за размерами окна браузера.
						// Эта функция вызовет hpmd.data.onViewportUpdate 
						// через 330 мс.
						hpmd.data.watchLayout();
					},
		
					/**
					 * Функция для перестройки верстки под изменившиеся размеры
					 * окна браузера.
					 *
					 * Эта функция вызывается каждый раз, когда изменяются размеры
					 * окна браузера в пикселях. Если вам необходимо вычислять размеры
					 * или расположение каких-либо элементов верстки динамически,
					 * поместите вычисления в эту функцию.
					 *
					 * Пожалуйста, обратите внимание, что существующий код в этой функции
					 * необходимо оставить без изменений.
					 */
					onViewportUpdate: function () {
						// Пересчитываем высоту тизера и растяжки
						if (!hpmd.data.bannerMinimized) {
							/* Тизер не свернут.
							 * Высота тизера определяется CSS-стилями.
							 * Высота растяжки равна полной высоте тизера.
							 */
							hpmd.data.nodes.stretch.style.height = hpmd.data.nodes.teaser.clientHeight + 'px';
						} else {
							/* Тизер свернут. */
							hpmd.data.nodes.stretch.style.height = 0;
						}
		
						// Пересчитываем размер заглушки и содержимого попапа:
						hpmd.data.nodes.splash.style.width = window.innerWidth + 'px';
						hpmd.data.nodes.splash.style.height = window.innerHeight + 'px';
						hpmd.data.nodes['popup-contents'].style.width = window.innerWidth + 'px';
						hpmd.data.nodes['popup-contents'].style.height = window.innerHeight + 'px';
		
						/**
						 * Сюда можно добавить свои правила для пересчета верстки.
						 * Используйте значения window.innerWidth и window.innerHeight
						 * в качестве базовых размеров для расчетов.
						 * Используйте функцию hpmd.data.isPortrait() для определения
						 * текущей ориентации устройства.
						 */
					},
					isLoaded: false,
		
					/**
					 * Игровая логика
					 */
		
		
				showFinalScreen: function () {
					var finalScreen = document.querySelector('.hpmd-final-screen');
					finalScreen.classList.remove('hpmd-hidden');
					setTimeout(function () {
						document.querySelector('.hpmd-final-screen').style.opacity = '1';
					}, 100);
				},
				hiddenStartScreen: function () {
					document.querySelector('.hpmd-header-arrow').style.display = 'none';
					document.querySelector('.hpmd-header-text').style.display = 'none';
					document.querySelector('.hpmd-footer-arrow').style.display = 'none';
					document.querySelector('.hpmd-footer-text').style.display = 'none';
				}
				};
		
				/* Инициализируем баннер. */
				hpmd.data.init();
		
				var images;
				images = [
					"./banner/img/handle-arrow.png",
					"./banner/img/handle.png",
					"./banner/img/teaser_logo.png",
					"./banner/img/teaser-portrait.png",
					"./banner/img/start_teaser.png",
					"./banner/img/play_teaser.png",
					"./banner/img/shirt.png",
					"./banner/img/grey_spot.png",
					"./banner/img/black_spot.png",
					"./banner/img/red_spot.png"
				];
		
				/**
				 * Запускаем предварительную загрузку картинок
				 */
				hpmd.data.preloadImages(images, function () {
					hpmd.data.bannerMinimized = false;
					hpmd.data.isLoaded = true;
					hpmd.data.forceCheckLayout();
		
					var img = [
						"./banner/img/bg.jpg",
						"./banner/img/medal.png",
						"./banner/img/list.png",
						"./banner/img/ligal.png",
						"./banner/img/try_now.png"
					];
		
					hpmd.data.preloadImages(img, function(){})
				});
		
				window.addEventListener('message', function(event) {
					try {
						var data = JSON.parse(event.data);
		
						if (!!data.name && data.name === 'hpmd') {
							switch(data.action) {
								case 'game-finished':
									hpmd.trackEvent('hpmd-autoshow-final-KV'); //автооткрытие финального вижуала
									hpmd.data.showFinalScreen();
									break;
								case 'user-finished-game':
									hpmd.trackEvent('hpmd-show-final-KV'); //открытие финального вижуала
									hpmd.data.showFinalScreen();
									break;
								case 'start-game':
									hpmd.trackEvent('hpmd-start-game');
									hpmd.data.hiddenStartScreen();
									clearTimeout(hpmd.data.timeoutId);
									break;
							}
						}
					} catch(e) {}
				});
		
				hpmd.data.handleSwipe(document.querySelector('.hpmd-logo'), {
					tap: function () {
						hpmd.trackEventBeacon('hpmd-logo-link');
						hpmd.data.minimizeBanner();
						hpmd.link();
					},
				});
		
				hpmd.data.handleSwipe(document.querySelector('.hpmd-final-screen'), {
					tap: function () {
						hpmd.trackEventBeacon('hpmd-final-link');
						hpmd.data.minimizeBanner();
						hpmd.link();
					},
				});
		} catch (err) {
			console.log(err)
		}
});</script>
<!-- /JS -->
<!-- =================================================================================================== -->

</body></html>
